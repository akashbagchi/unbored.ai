---
sidebar_position: 1
---

# akashbagchi/claude-builder-2025 - Architecture Overview

# Understanding the Ghost Onboarder Codebase

## Understanding the Codebase

Ghost Onboarder follows a pipeline-driven architecture, where discrete processing stages transform a repository into documentation. The codebase is split between a Python-based analysis pipeline and a React-based documentation site, connected through JSONL data files.

The core architectural pattern is a multi-stage processor where each stage has a single responsibility:
1. Repository scanning (`cli/scanner.py`)
2. Content analysis (`cli/score_repo_files.py`) 
3. AI processing (`cli/claude_client.py`)
4. Site generation (`ghost-onboarder-site/`)

The most important concept to grasp is the data flow between stages - each processor expects specific JSONL formats from the previous stage. Changes to output formats require coordinated updates across multiple files.

## Code Organization & Flow

**`cli/` Directory**
- **Purpose**: Contains the core repository analysis pipeline
- **Key files**: 
  - `scanner.py` - Walks repository structure and extracts metadata
  - `score_repo_files.py` - Analyzes file importance and relationships
  - `claude_client.py` - Handles AI processing via AWS Lambda
- **When you'll touch this**: Adding new file analysis capabilities or modifying the scanning logic
- **Gotchas**: `scanner.py` and `score_repo_files.py` are tightly coupled - changes to scanning output require updates to scoring logic

**`outputs/` Directory**
- **Purpose**: Stores intermediate processing results between pipeline stages
- **Key files**:
  - `scan.jsonl` - Raw repository scan data
  - `scan.jsonl.graph.json` - Processed dependency relationships
- **When you'll touch this**: Debugging pipeline issues or modifying data formats
- **Gotchas**: Files are overwritten on each run - back up if needed for debugging

**`ghost-onboarder-site/` Directory**
- **Purpose**: Docusaurus-based documentation site that displays analysis results
- **Key files**:
  - `src/pages/graph.tsx` - Interactive repository visualization
  - `docs/intro.md` - AI-generated architecture overview
- **When you'll touch this**: Customizing documentation layout or visualization
- **Gotchas**: Graph visualization expects specific JSON schema from `generate_graph_position.py`

## Data Flow Paths

**Repository Analysis Pipeline**
1. `generator.py` invokes `cli/main.py` with repository path
2. `scanner.py` walks files and outputs to `outputs/scan.jsonl`
3. `score_repo_files.py` analyzes importance and writes `scan.issues.jsonl`
4. `generate_graph_position.py` creates visualization data in `scan.jsonl.graph.json`
5. `claude_client.py` processes scan data through Lambda for documentation
6. Generated content updates `ghost-onboarder-site/docs/intro.md`

**Documentation Site Updates**
1. Site watches `docs/intro.md` for content changes
2. `src/pages/graph.tsx` loads `graph_with_pos.json` on render
3. Docusaurus rebuilds affected pages automatically
4. Changes appear in development server or production build

## Key Architectural Decisions

**Lambda vs Direct API**
- Uses AWS Lambda to proxy Claude API calls for several reasons:
- Keeps API keys secure and centralized
- Enables request/response transformation
- Provides usage monitoring and quotas
- You'll find Lambda logic in `cli/lambda_function.py`

**JSONL vs JSON**
- JSONL chosen for pipeline data format because:
- Supports streaming processing of large repos
- Each line is valid JSON (easier debugging)
- Natural fit for file-by-file analysis
- See format examples in `outputs/scan.jsonl`

**Docusaurus Integration**
- Updates existing site rather than generating from scratch:
- Preserves custom styling and configuration
- Allows mixing generated and manual content
- Enables incremental updates
- Integration happens in `ghost-onboarder-site/docs/`

**Graph Visualization**
- Uses React Flow for repository visualization:
- Interactive node dragging and zooming
- Custom node rendering capabilities
- Force-directed layout algorithm
- Implementation in `src/pages/graph.tsx`

The codebase emphasizes pipeline modularity while maintaining strict data contracts between stages. When making changes, you'll need to consider impacts across the entire flow from scanning through visualization.

Common pain points include:
- Coordinating changes to JSONL formats across multiple files
- Debugging Lambda integration issues
- Managing state between pipeline runs
- Customizing Docusaurus without breaking generated content

Focus on understanding the data flow first - most bugs stem from mismatched expectations between pipeline stages rather than issues within individual components.

---

*This documentation was automatically generated by Ghost Onboarder using Claude AI.*
